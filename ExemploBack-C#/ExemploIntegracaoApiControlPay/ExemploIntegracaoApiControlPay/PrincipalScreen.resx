<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBoxInfoTerminal1.Text" xml:space="preserve">
    <value>Para realizar transações no ControlPay, é necessário possuir um terminal (e no caso de transações TEF, ele deve estar associado ao ponto de captura desejado). Terminais são como direcionamos as transações para os locais corretos na plataforma. É importante ressaltar que, no caso de transações TEF, é necessário que o PayGo Windows esteja aberto na máquina em que estiver instalado e que tenha sido ativado com o ponto de captura que será usado.

Caso não tenha um terminal, selecione um terminal físico (que representa o ponto de captura, PdC, no ControlPay) a ser usado e, então, clique no botão para criar um terminal relacionado a este PDC.</value>
  </data>
  <data name="textBoxExplainingText.Text" xml:space="preserve">
    <value>Esta aplicação é um exemplo de uso das APIs do ControlPay. para seu uso, é necessário primeiro que se tenha um usuário ativo e configurado no ControlPay, no ambiente de Sandbox (e também é recomendado que o portal esteja aberto para uso conjunto com este exemplo, para que haja uma maior clareza dos conceitos aqui mostrados).

Esta aplicação age como uma automação comercial fictícia realizando vendas via API. Sendo assim, é necessário que haja um PayGo Windows instalado e configurado. Caso sejam necessárias mais informações, elas serão requisitadas em suas secções abaixo.

Também é importante ressaltar que é necessário realizar as ações desta aplicação etapa por etapa e em ordem, já que há secções que dependem de outras (as transações dependem da chave adquirida no login, as administrativas ocorrerão no terminal selecionado na secção de transações, e assim por diante).

Para começar, basta seguir para a próxima aba usando o seletor no topo desta tela.</value>
  </data>
  <data name="textBoxInfoLogin.Text" xml:space="preserve">
    <value>Para realizar chamadas ao ControlPay, é preciso ter uma chave de integração.

Esta chave de integração pode ser adquirida usando o login de usuário (sendo uma chave que expirará em, aproximadamente, um dia), ou pode ser cadastrada no portal ControlPay (tendo um tempo de expiração maleável, ou até podendo não expirar).</value>
  </data>
  <data name="textBoxInfoStartAuto.Text" xml:space="preserve">
    <value>Transações podem ser iniciadas automaticamente (iniciando o processamento no PayGo Windows assim que possível) ou não (deixando que o usuário as inicie na tela de "Transações" do próprio PGWin). O checkbox abaixo indica esta exata configuração.</value>
  </data>
  <data name="textBoxInfoTransacoes.Text" xml:space="preserve">
    <value>Para realizar transações no ControlPay, algumas coisas são importantes:

- É preciso ter tido sua conta configurada para permitir vendas. Isso é realizado pelo nosso time de relacionamento com o desenvolvedor. Caso ainda não tenha entrado em contato, peça que realizem estas configurações;

- É preciso ter realizado as etapas anteriores deste exemplo resgate da chave de integração que permite usar as APIs, ter um PayGo Windows instalado (para uso TEF) e ter um terminal pronto para uso no ControlPay.

Com tudo preparado, é possível realizar transações escolhendo os parâmetros abaixo e clicando no botão para transacionar.</value>
  </data>
  <data name="textBoxInfoAdministrativas.Text" xml:space="preserve">
    <value>O ControlPay também suporta chamadas de transações administrativas para TEF, utilizando o PayGo Windows. Para esta etapa, será preciso utilizar a senha técnica cadastrada no ControlPay. Caso não tenha cadastrado uma senha técnica, não preencha a caixa abaixo, assim usaremos uma senha padrão.</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAABILAAASCwAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAb2JnAG9iZwBrXmUAbmFnAGVYYgBtYGYBcWRoAHBjaAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAb2xrAG9raxNwbWx3cG1tg3BtbCRwbW1KcG1tknBtbExwZGUCcGhpAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBubQBwbm1ocG5t6XBubeRwbWyxcG5t03Bubd9wbm3VcG1tHnBt
        bQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwbm0AcG5tZXBubehwbm3icG1sznBubOhxbmvfcG5s0W9t
        bR1wbWwAAAAAAAAAAAAAAAAA36swANuoMA7dqTA44KsuInRvaRNwbm2wcG5t63BubOFnbn/JXm6Vt2Rt
        hlQ7bN0NNm7sNjZu7CU0buoBNW7rANimMATdqTCI3qow5t+qL8mZhFVyb21t23BubPVobn/VPG/h0zVv
        8OE2bu6jN27slDdv7eQ3b+3PN27sMjdu7ADbqDAO3qowwd2qMNPgqy/jnIZUx25tbuFxbmrWYG6Q1jdv
        7Ok2b+3MN2/t9Ddv7PA2buzRN2/t6Ddv7Fc3b+wAwpwwAN2pMGHeqjDP36ov5cSbPsB5cmjHcm9rx2Rt
        hlc3bemaO2vg3jhu6eg2b+3ZN2/t2Ddv7aw2buwdN27sAN+qMADdqTBP3qkwyt2qMNLeqjDi1qU00dSk
        Nb/TnS1Cbjo8iW48Qd1cTHjTOWzl4zZv7do3buycNm7sFDZu7ADcqDAM3qowu92pMNLeqjDo3qow8d6q
        MOTfqzDVypUwxHQ5MNlzNy/LcDo460Flzd42b+/UN2/t6Ddv7VU3b+0A26YwBt2pMJjeqjDo3qow2d6q
        MJvfrDDb4Kww4raAMMlzODHoczgx8XE5NbQ9adiiNm/u6jdv7dw3buw7N27sAN2qMADcqDAY3akwW96r
        MDmYYDAZnWYwq5xkMNl6QDHfcjcx3HM4Me5zNy9jNG/uFjZu7Fk3bus9NGflAzVq5wAAAAAAAAAAAAAA
        AAByNzEAcjcxYnE2MeZxNjHlcjcx03M4MdpzODHeczgx0HI4MB1yODAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAczgxAHM4MWhzODHpczgx5HI4Ma9zODHSczgx33M4MdhzODEfczgxAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAHI3MAByNjATcjcxeXI4MYpyODAlcjgxSnM4MZRyNzBOcDQvAnE1MAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAbjQtAG41LQFrNiwBbTMsAF0tJgBrMywBcDQtAG80LQAAAAAAAAAAAAAA
        AAAAAAAA+R8AAPAPAADwDwAA8A8AAIABAAAAAQAAAAEAAAABAACAAQAAAAEAAAABAACAAQAA8A8AAPAP
        AADwDwAA+R8AAA==
</value>
  </data>
</root>